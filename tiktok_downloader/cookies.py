"""
Cookie management functionality for TikTok content extraction.

This module provides an instance-based CookieManager that can load,
save, convert, and simplify cookies in JSON and Netscape formats. It
supports both JSONCookie dictionaries and Playwright Cookie objects.
"""

from __future__ import annotations

import json
from collections.abc import Iterable
from os import PathLike
from pathlib import Path
from typing import Protocol, TextIO, TypedDict

import platformdirs
from playwright.sync_api import Cookie as PlaywrightCookieType

from .logger import get_logger

logger = get_logger(__name__)


class JSONCookie(TypedDict):
    """
    TypedDict for JSON-serializable cookies (often from browser extensions).

    Attributes:
        name: The name of the cookie. (Required)
        value: The value of the cookie. (Required)
        domain: The domain for which the cookie is valid. (Required)
        path: The URL path for which the cookie is valid. (Optional, defaults to "/")
        secure: Whether the cookie is only sent over HTTPS. (Optional, defaults to False)
        httpOnly: Whether the cookie is inaccessible to JavaScript. (Optional, defaults to False)
        expirationDate: The UNIX timestamp when the cookie expires (Optional)
        expires: Alias for expirationDate or primary key in Playwright. (Optional)
    """

    # Fields essential to basic cookie functionality are marked Required
    name: Required[str]
    value: Required[str]
    domain: Required[str]

    # Mark non-essential fields NotRequired
    path: NotRequired[str]
    secure: NotRequired[bool]
    httpOnly: NotRequired[bool]
    expirationDate: NotRequired[float]  # Often used in JSON exports like GetCookies.txt
    expires: NotRequired[float]  # Used by Playwright (-1 for session cookies)


# Note: Playwright's Cookie type is also a TypedDict, similar to JSONCookie but
# uses 'expires' instead of 'expirationDate' and includes 'sameSite'.
# We accept JSONCookie | PlaywrightCookieType where applicable.


# Protocol remains useful for defining minimum requirements if needed elsewhere,
# but direct type hints are clearer for known types like PlaywrightCookieType.
class CookieLike(Protocol):
    """
    Protocol for objects that have cookie-like attributes.

    Attributes:
        name: The name of the cookie.
        value: The value of the cookie.
        domain: The domain for which the cookie is valid.
        path: The URL path for which the cookie is valid.
        secure: Whether the cookie is only sent over HTTPS.
        expires: The UNIX timestamp when the cookie expires.
    """

    name: str
    value: str
    domain: str
    path: str
    secure: bool
    expires: float


def _parse_expires(raw_exp: int | float | str | None = None) -> int:
    """
    Safely parse various expiration representations into an integer timestamp.

    Handles None, int, float, and string representations of numbers.
    Defaults to 0 if parsing fails or input is unsuitable.
    Handles Playwright's -1 for session cookies (maps to 0 in Netscape).
    """
    # Check for Playwright's session cookie value (-1.0 or -1)
    try:
        if raw_exp is not None and float(raw_exp) == -1.0:
            return 0  # Netscape format uses 0 for session cookies
    except (ValueError, TypeError):
        pass  # Ignore if conversion to float fails, proceed to other checks

    if raw_exp is None:
        return 0
    try:
        # Use float conversion first to handle potential float values or "123.0" strings
        return int(float(raw_exp))
    except (ValueError, TypeError):
        # Return 0 for non-numeric strings, incompatible types
        logger.debug("Could not parse expires value '%s' to int, defaulting to 0.", raw_exp)
        return 0


def _write_netscape(cookies: Iterable[JSONCookie | PlaywrightCookieType], file: TextIO) -> None:
    """
    Write cookies in Netscape HTTP Cookie File format to an open file.

    Processes an iterable of either JSONCookie dicts or objects conforming
    to CookieLike, and writes each cookie line according to the Netscape
    specification.

    Args:
        cookies: An iterable of JSONCookie dictionaries or Playwright Cookie.
        file: An open text file (IO) to write the Netscape-formatted cookies.

    Raises:
        None. Invalid cookie entries are skipped with a warning.
    """
    file.write("# Netscape HTTP Cookie File\n")
    file.write("# Generated by CookieManager\n\n")

    for idx, cookie in enumerate(cookies):
        # Since both JSONCookie and Playwright Cookie are dicts (TypedDict),
        # we need to primarily handle the dictionary structure
        if isinstance(cookie, dict):
            try:
                # Ensure defaults are sensible for Netscape format requirements
                domain = cookie.get("domain", "")
                name = cookie.get("name", "")
                value = cookie.get("value", "")
                path = cookie.get("path", "/")
                secure = bool(cookie.get("secure", False))

                # Handle expiration date - prioritize 'expirationDate', then 'expires'
                # Ignore because MyPy thinks this is an 'object' type, I assume because the
                # PlaywrightCookieType doesn't have the expirationDate key
                exp_date: float | None = cookie.get("expirationDate")  # type: ignore[assignment]
                expires = cookie.get("expires")

                value_to_parse: float | int | str | None = exp_date or expires or None

                # Basic validation: domain & name are crucial for Netscape format
                if not domain or not name:
                    logger.warning(
                        "Skipping cookie #%d: Missing required domain ('%s') or name ('%s'). Cookie data: %r",  # noqa: E501
                        idx,
                        domain,
                        name,
                        cookie,
                    )
                    continue

                # Process and Format data
                expires_timestamp = _parse_expires(value_to_parse)
                # Netscape host-only flag: TRUE if domain doesn't start with '.', FALSE if it does
                # A leading dot means it's valid for subdomains.
                host_only_flag = "FALSE" if domain.startswith(".") else "TRUE"
                secure_flag = "TRUE" if secure else "FALSE"

                # Write the formatted line
                # Format: domain<TAB>hostOnlyFlag<TAB>path<TAB>secureFlag<TAB>expires<TAB>name<TAB>value  # noqa: E501
                file.write(
                    f"{domain}\t{host_only_flag}\t{path}\t{secure_flag}\t"
                    f"{expires_timestamp}\t{name}\t{value}\n"
                )
            except Exception as e:
                logger.warning(
                    "Skipping cookie #%d due to processing error: %s - %s. Cookie data: %r",
                    idx,
                    type(e).__name__,
                    e,
                    cookie,
                )
                continue


class CookieManager:
    """
    Manages cookie storage and conversion for TikTok extraction.

    This class allows loading and saving cookies to JSON files,
    converting them to Netscape format, and simplifying for browser use.

    Attributes:
        storage_dir: Directory path where cookie profiles are stored.
    """

    def __init__(self, storage_dir: PathLike | None = None) -> None:
        """
        Initialize a CookieManager instance.

        Args:
            storage_dir (PathLike | None, optional): Directory in which
                to store cookie profiles. If None, uses the platform-specific
                user data directory.
        """
        if storage_dir is None:
            data_dir = platformdirs.user_data_dir(
                appname="tiktok_extractor", appauthor="TikTokExtractor"
            )
            self.storage_dir = Path(data_dir)
        else:
            self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)

    def load(self, profile: str) -> list[JSONCookie]:
        """
        Load cookies from a JSON profile file.

        Args:
            profile (str): Name of the cookie profile (without extension).

        Returns:
            list[JSONCookie]: A list of JSONCookie dicts.

        Raises:
            FileNotFoundError: If the profile file does not exist.
            ValueError: If the file contains invalid JSON.
        """
        path = self.storage_dir / f"{profile}.json"
        if not path.is_file():
            msg = f"Cookie file not found: {path}"
            logger.error(msg)
            raise FileNotFoundError(msg)
        try:
            logger.debug("Loading cookies from %s", path)
            # XXX: Pydantic for type safe JSON loading, but for now ignore.
            return json.loads(path.read_text(encoding="utf-8"))  # type: ignore
        except json.JSONDecodeError as e:
            msg = f"Invalid JSON in cookie file {path}"
            logger.exception(msg)
            raise ValueError(msg) from e

    def save(self, cookies: list[JSONCookie], profile: str) -> Path:
        """Save cookies to  JSON profile file.

        Args:
            cookies (list[JSONCookie]): List of JSONCookie dicts to save.
            profile (str): Name of the cookie profile (without extension).

        Returns:
            Path: Path to the saved JSON file.

        Raises:
            OSError: On failure to write to disk.
        """
        path = self.storage_dir / f"{profile}.json"
        try:
            path.write_text(json.dumps(cookies, indent=2), encoding="utf-8")
            logger.info("Saved %d cookies to %s", len(cookies), path)
            return path
        except Exception:
            logger.exception("Failed to save cookies")
            raise


async def fetch_cookies(
    profile: str,
    browser: str = "chromium",
    headless: bool = False,
    user_data_dir: Path | None = None,
) -> list[JSONCookie]:
    """Launch a browser, let the user log in, and return collected cookies."""

    import asyncio

    from playwright.async_api import async_playwright

    logger.info("Launching %s for profile '%s'", browser, profile)

    async with async_playwright() as pw:
        browser_type = getattr(pw, browser)

        if user_data_dir is not None:
            context = await browser_type.launch_persistent_context(
                str(user_data_dir), headless=headless
            )
            b = None
        else:
            b = await browser_type.launch(headless=headless)
            context = await b.new_context()

        page = await context.new_page()
        await page.goto("https://www.tiktok.com/")
        await asyncio.to_thread(input, "Press Enter once logged in")
        cookies = await context.cookies()

        await context.close()
        if b is not None:
            await b.close()

    result: list[JSONCookie] = []
    for cookie in cookies:
        expires = cookie.get("expires", 0)
        result.append(
            {
                "name": cookie.get("name", ""),
                "value": cookie.get("value", ""),
                "domain": cookie.get("domain", ""),
                "path": cookie.get("path", "/"),
                "secure": bool(cookie.get("secure", False)),
                "httpOnly": bool(cookie.get("httpOnly", False)),
                "expirationDate": expires,
                "expires": expires,
            }
        )

    logger.info("Fetched %d cookies", len(result))
    return result
